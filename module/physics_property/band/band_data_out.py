import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from files_api.Files_out import FilesOut
import numpy as np
import os


class BandDataOut(FilesOut):
    def __init__(self,file_path,content={}) -> None:
        super(BandDataOut,self).__init__()
        self.before_step = FilesOut()
        self.file_path = file_path
        self.description = "存储{}文件，记录band信息".format(self.file_path)
        self.content = content
        self.file_type = os.path.splitext(file_path)[1]
        
        self.check()
        
        
    def check(self):
        if self.file_type == ('',):
            AssertionError("这不是一个文件路径，请输入正确路径")
        
        
    def get_content(self,content:dict):
        self.content = content
        
        
    def save_content(self):
        self.__module_choose()
        
    
    def __module_choose(self):
        if self.content == {}:
            Warning("{}文件输出任务中，并没有储存任何值".format(self.file_path))
        if self.file_type == ".npz":
            self.__save_content_npz()
        elif self.file_type == ".dat":
            self.__save_content_dat()

    def __save_content_dat(self):
        """该函数用于模仿VASPKIT生成的Line-Mode类型能带文件生成模型的能带文件
        """
        def write_kpoints(f_kpoints,n_kpoint,kpath,kpoints):
            f_kpoints.write("K-Path Generated by VASPKIT.\n")
            f_kpoints.write("   "+str(n_kpoint)+"\n")
            f_kpoints.write("Line-Mode\n")
            f_kpoints.write("Reciprocal\n")
            index = 0
            k_vector_list = []
            for path in kpath:
                k_vector_list.append({path[0]:kpoints[index],path[1]:kpoints[index+n_kpoint-1]})
                index = index+n_kpoint
            n_path = len(k_vector_list)
            for i in range(n_path):
                f_kpoints.write("   "+format(k_vector_list[i][kpath[i][0]][0],".10f")+"   "+format(k_vector_list[i][kpath[i][0]][1],".10f")+"   "+format(k_vector_list[i][kpath[i][0]][2],".10f")+"     "+kpath[i][0])
                f_kpoints.write("\n")
                f_kpoints.write("   "+format(k_vector_list[i][kpath[i][1]][0],".10f")+"   "+format(k_vector_list[i][kpath[i][1]][1],".10f")+"   "+format(k_vector_list[i][kpath[i][1]][2],".10f")+"     "+kpath[i][1])
                f_kpoints.write("\n")
                f_kpoints.write("\n")
            f_kpoints.close()


        def write_klabels(f_klabels,kpath):
            f_klabels.write("K-Label    Coordinate of high-symmetry k-point in band-structure plots \n")
            n_path = len(kpath)
            k_labels = []
            for i in range(n_path):
                if i == 0:
                    k_labels.append(kpath[i][0])
                else:
                    if kpath[i][0] == kpath[i-1][1]:
                        k_labels.append(kpath[i][0])
                    else:k_labels.append(kpath[i-1][1]+"|"+kpath[i][0])
            k_labels.append(kpath[-1][1])
            k_position = np.linspace(0, 1, n_path + 1)
            for i in range(n_path+1):
                f_klabels.write(k_labels[i]+"       "+format(k_position[i],".3f")+"\n")
            f_klabels.write("\n\n")
            f_klabels.write("* Give the label for each high symmetry point in KPOINTS (KPATH.in) file. Otherwise, they will be identified as 'Undefined' in KLABELS file\n")
            f_klabels.close()


        def write_band(f_dat,energy):
            nkpts = energy.shape[0]
            nbands = energy.shape[1]
            f_dat.write("#K-Path(1/A)         Spin-Up(eV)   Spin-down(eV)\n")
            f_dat.write("# NKPTS & NBANDS: "+str(nkpts)+" "+str(nbands))
            


        folder_path = os.path.dirname(self.file_path)
        f_dat = open(self.file_path,"w")
        f_kpoints = open(os.path.join(folder_path,"KPOINTS"),"w")
        f_klabels = open(os.path.join(folder_path,"KLABELS"),"w")

        
        energy = self.content['energy']
        n_kpoints = self.content['n_kpoint']
        kpath = self.content['kpath']
        kpoints = self.content['k_vector']
        write_kpoints(f_kpoints,n_kpoints,kpath,kpoints)
        write_klabels(f_klabels,kpath)



    
            
    def __save_content_npz(self):
        """
        储存band的npz文件有两个部分，分别是k_point和energy，二者一一对应，也就是k_point的个数和energy的个数应该相等
        k_point的文件形状是(n_point,3)
        energy的文件形状是(n_point,n_band)
        """
        np.savez(self.file_path,**self.content)